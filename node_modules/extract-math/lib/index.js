"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SEGMENTS_REGEX = /(\\\$)|\$\$(.*?[^\\])\$\$|\$(.*?[^\\])\$/;
function extractMath(input) {
    var _a, _b, _c, _d;
    var segments = [];
    var dollar;
    var display;
    var inline;
    var _e = __read(input.split(exports.SEGMENTS_REGEX)), text = _e[0], parts = _e.slice(1);
    pushText(segments, text);
    while (parts.length > 0) {
        _a = parts, _b = __read(_a), dollar = _b[0], display = _b[1], inline = _b[2], parts = _b.slice(3);
        if (dollar) {
            pushText(segments, '$');
        }
        else if (display) {
            pushMath(segments, 'display', display);
        }
        else if (inline) {
            pushMath(segments, 'inline', inline);
        }
        _c = parts, _d = __read(_c), text = _d[0], parts = _d.slice(1);
        pushText(segments, text);
    }
    return segments;
}
exports.extractMath = extractMath;
function pushText(segments, text) {
    if (!text) {
        return;
    }
    var last = segments[segments.length - 1];
    if (last && last.type === 'text') {
        last.value += text;
        last.raw += text;
    }
    else {
        segments.push({ type: 'text', math: false, value: text, raw: text });
    }
}
function pushMath(segments, mode, text) {
    if (!text) {
        return;
    }
    segments.push({ type: mode, math: true, value: text.replace(/\\\$/g, '$'), raw: text });
}
//# sourceMappingURL=index.js.map