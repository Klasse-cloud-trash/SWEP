import { EventEmitter, Component, Input, Output, ChangeDetectionStrategy, Injectable, Directive, ElementRef, NgModule } from '@angular/core';
import { extractMath } from 'extract-math';
import { CommonModule } from '@angular/common';
import { render, renderToString } from 'katex';
import { DomSanitizer } from '@angular/platform-browser';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class KatexComponent {
    constructor() {
        this.onError = new EventEmitter();
    }
    /**
     * @param {?} error
     * @return {?}
     */
    hasError(error) {
        this.onError.emit(error);
    }
}
KatexComponent.decorators = [
    { type: Component, args: [{
                selector: 'ng-katex',
                template: `
    <span [katex]="equation"
          [katex-options]="options"
          (someEvent)="hasError($event)">
    </span>
  `
            }] }
];
KatexComponent.propDecorators = {
    equation: [{ type: Input }],
    options: [{ type: Input }],
    onError: [{ type: Output }]
};
if (false) {
    /** @type {?} */
    KatexComponent.prototype.equation;
    /** @type {?} */
    KatexComponent.prototype.options;
    /** @type {?} */
    KatexComponent.prototype.onError;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class KatexParagraphComponent {
    /**
     * @return {?}
     */
    get segments() {
        return extractMath(this.paragraph);
    }
}
KatexParagraphComponent.decorators = [
    { type: Component, args: [{
                selector: 'ng-katex-paragraph',
                template: `
    <p>
      <ng-container *ngFor="let segment of segments">
        <ng-katex
          *ngIf="segment.math else text"
          [equation]="segment.raw"
          [options]="{ displayMode: segment.type === 'display' }">
        </ng-katex>
        <ng-template #text>{{ segment.value }}</ng-template>
      </ng-container>
    </p>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush
            }] }
];
KatexParagraphComponent.propDecorators = {
    paragraph: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    KatexParagraphComponent.prototype.paragraph;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class KatexService {
    /**
     * @param {?} equation
     * @param {?} element
     * @param {?=} options
     * @return {?}
     */
    render(equation, element, options) {
        return render(equation, element.nativeElement, options);
    }
    /**
     * @param {?} equation
     * @param {?=} options
     * @return {?}
     */
    renderToString(equation, options) {
        return renderToString(equation, options);
    }
}
KatexService.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class KatexDirective {
    /**
     * @param {?} el
     * @param {?} katexService
     */
    constructor(el, katexService) {
        this.el = el;
        this.katexService = katexService;
        this.onError = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
        try {
            this.katexService.render(this.equation, this.el, this.options);
        }
        catch (e) {
            this.onError.emit(e);
        }
    }
}
KatexDirective.decorators = [
    { type: Directive, args: [{
                selector: '[katex]',
            },] }
];
/** @nocollapse */
KatexDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: KatexService }
];
KatexDirective.propDecorators = {
    equation: [{ type: Input, args: ['katex',] }],
    options: [{ type: Input, args: ['katex-options',] }],
    onError: [{ type: Output }]
};
if (false) {
    /** @type {?} */
    KatexDirective.prototype.equation;
    /** @type {?} */
    KatexDirective.prototype.options;
    /** @type {?} */
    KatexDirective.prototype.onError;
    /**
     * @type {?}
     * @private
     */
    KatexDirective.prototype.el;
    /**
     * @type {?}
     * @private
     */
    KatexDirective.prototype.katexService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class KatexHtmlComponent {
    /**
     * @param {?} domSanitizer
     * @param {?} katexService
     */
    constructor(domSanitizer, katexService) {
        this.domSanitizer = domSanitizer;
        this.katexService = katexService;
    }
    /**
     * @return {?}
     */
    get allHtml() {
        /** @type {?} */
        let segments = this.segments;
        /** @type {?} */
        var allHtml = segments.map((/**
         * @param {?} seg
         * @return {?}
         */
        (seg) => {
            if (seg.math) {
                return this.katexService.renderToString(seg.raw, { displayMode: seg.type === 'display' });
            }
            else {
                return seg.value;
            }
        })).reduce((/**
         * @param {?} total
         * @param {?} current
         * @return {?}
         */
        (total, current) => {
            return total += current;
        }));
        return this.domSanitizer.bypassSecurityTrustHtml(allHtml);
    }
    /**
     * @return {?}
     */
    get segments() {
        return extractMath(this.html);
    }
}
KatexHtmlComponent.decorators = [
    { type: Component, args: [{
                selector: 'ng-katex-html',
                template: `<span [innerHTML]="allHtml"></span>`
            }] }
];
/** @nocollapse */
KatexHtmlComponent.ctorParameters = () => [
    { type: DomSanitizer },
    { type: KatexService }
];
KatexHtmlComponent.propDecorators = {
    html: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    KatexHtmlComponent.prototype.html;
    /**
     * @type {?}
     * @private
     */
    KatexHtmlComponent.prototype.domSanitizer;
    /**
     * @type {?}
     * @private
     */
    KatexHtmlComponent.prototype.katexService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class KatexModule {
}
KatexModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                ],
                providers: [
                    KatexService,
                ],
                declarations: [
                    KatexDirective,
                    KatexComponent,
                    KatexParagraphComponent,
                    KatexHtmlComponent
                ],
                exports: [
                    KatexComponent,
                    KatexParagraphComponent,
                    KatexHtmlComponent
                ],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { KatexComponent, KatexModule, KatexParagraphComponent, KatexService as ɵa, KatexDirective as ɵb, KatexHtmlComponent as ɵc };
//# sourceMappingURL=ng-katex.js.map
