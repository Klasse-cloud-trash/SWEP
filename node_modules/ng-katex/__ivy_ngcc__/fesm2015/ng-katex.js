import { EventEmitter, Component, Input, Output, ChangeDetectionStrategy, Injectable, Directive, ElementRef, NgModule } from '@angular/core';
import { extractMath } from 'extract-math';
import { CommonModule } from '@angular/common';
import { render, renderToString } from 'katex';
import { DomSanitizer } from '@angular/platform-browser';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';
import * as ɵngcc2 from '@angular/platform-browser';

const _c0 = function (a0) { return { displayMode: a0 }; };
function KatexParagraphComponent_ng_container_1_ng_katex_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "ng-katex", 3);
} if (rf & 2) {
    const segment_r1 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵproperty("equation", segment_r1.raw)("options", ɵngcc0.ɵɵpureFunction1(2, _c0, segment_r1.type === "display"));
} }
function KatexParagraphComponent_ng_container_1_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtext(0);
} if (rf & 2) {
    const segment_r1 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵtextInterpolate(segment_r1.value);
} }
function KatexParagraphComponent_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, KatexParagraphComponent_ng_container_1_ng_katex_1_Template, 1, 4, "ng-katex", 1);
    ɵngcc0.ɵɵtemplate(2, KatexParagraphComponent_ng_container_1_ng_template_2_Template, 1, 1, "ng-template", null, 2, ɵngcc0.ɵɵtemplateRefExtractor);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const segment_r1 = ctx.$implicit;
    const _r3 = ɵngcc0.ɵɵreference(3);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", segment_r1.math)("ngIfElse", _r3);
} }
class KatexComponent {
    constructor() {
        this.onError = new EventEmitter();
    }
    /**
     * @param {?} error
     * @return {?}
     */
    hasError(error) {
        this.onError.emit(error);
    }
}
KatexComponent.ɵfac = function KatexComponent_Factory(t) { return new (t || KatexComponent)(); };
KatexComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: KatexComponent, selectors: [["ng-katex"]], inputs: { equation: "equation", options: "options" }, outputs: { onError: "onError" }, decls: 1, vars: 2, consts: [[3, "katex", "katex-options", "someEvent"]], template: function KatexComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "span", 0);
        ɵngcc0.ɵɵlistener("someEvent", function KatexComponent_Template_span_someEvent_0_listener($event) { return ctx.hasError($event); });
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("katex", ctx.equation)("katex-options", ctx.options);
    } }, directives: function () { return [KatexDirective]; }, encapsulation: 2 });
KatexComponent.propDecorators = {
    equation: [{ type: Input }],
    options: [{ type: Input }],
    onError: [{ type: Output }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(KatexComponent, [{
        type: Component,
        args: [{
                selector: 'ng-katex',
                template: `
    <span [katex]="equation"
          [katex-options]="options"
          (someEvent)="hasError($event)">
    </span>
  `
            }]
    }], function () { return []; }, { onError: [{
            type: Output
        }], equation: [{
            type: Input
        }], options: [{
            type: Input
        }] }); })();
if (false) {
    /** @type {?} */
    KatexComponent.prototype.equation;
    /** @type {?} */
    KatexComponent.prototype.options;
    /** @type {?} */
    KatexComponent.prototype.onError;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class KatexParagraphComponent {
    /**
     * @return {?}
     */
    get segments() {
        return extractMath(this.paragraph);
    }
}
KatexParagraphComponent.ɵfac = function KatexParagraphComponent_Factory(t) { return new (t || KatexParagraphComponent)(); };
KatexParagraphComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: KatexParagraphComponent, selectors: [["ng-katex-paragraph"]], inputs: { paragraph: "paragraph" }, decls: 2, vars: 1, consts: [[4, "ngFor", "ngForOf"], [3, "equation", "options", 4, "ngIf", "ngIfElse"], ["text", ""], [3, "equation", "options"]], template: function KatexParagraphComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "p");
        ɵngcc0.ɵɵtemplate(1, KatexParagraphComponent_ng_container_1_Template, 4, 2, "ng-container", 0);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.segments);
    } }, directives: [ɵngcc1.NgForOf, ɵngcc1.NgIf, KatexComponent], encapsulation: 2, changeDetection: 0 });
KatexParagraphComponent.propDecorators = {
    paragraph: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(KatexParagraphComponent, [{
        type: Component,
        args: [{
                selector: 'ng-katex-paragraph',
                template: `
    <p>
      <ng-container *ngFor="let segment of segments">
        <ng-katex
          *ngIf="segment.math else text"
          [equation]="segment.raw"
          [options]="{ displayMode: segment.type === 'display' }">
        </ng-katex>
        <ng-template #text>{{ segment.value }}</ng-template>
      </ng-container>
    </p>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], null, { paragraph: [{
            type: Input
        }] }); })();
if (false) {
    /** @type {?} */
    KatexParagraphComponent.prototype.paragraph;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class KatexService {
    /**
     * @param {?} equation
     * @param {?} element
     * @param {?=} options
     * @return {?}
     */
    render(equation, element, options) {
        return render(equation, element.nativeElement, options);
    }
    /**
     * @param {?} equation
     * @param {?=} options
     * @return {?}
     */
    renderToString(equation, options) {
        return renderToString(equation, options);
    }
}
KatexService.ɵfac = function KatexService_Factory(t) { return new (t || KatexService)(); };
KatexService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: KatexService, factory: KatexService.ɵfac });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(KatexService, [{
        type: Injectable
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class KatexDirective {
    /**
     * @param {?} el
     * @param {?} katexService
     */
    constructor(el, katexService) {
        this.el = el;
        this.katexService = katexService;
        this.onError = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
        try {
            this.katexService.render(this.equation, this.el, this.options);
        }
        catch (e) {
            this.onError.emit(e);
        }
    }
}
KatexDirective.ɵfac = function KatexDirective_Factory(t) { return new (t || KatexDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(KatexService)); };
KatexDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: KatexDirective, selectors: [["", "katex", ""]], inputs: { equation: ["katex", "equation"], options: ["katex-options", "options"] }, outputs: { onError: "onError" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
/** @nocollapse */
KatexDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: KatexService }
];
KatexDirective.propDecorators = {
    equation: [{ type: Input, args: ['katex',] }],
    options: [{ type: Input, args: ['katex-options',] }],
    onError: [{ type: Output }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(KatexDirective, [{
        type: Directive,
        args: [{
                selector: '[katex]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: KatexService }]; }, { onError: [{
            type: Output
        }], equation: [{
            type: Input,
            args: ['katex']
        }], options: [{
            type: Input,
            args: ['katex-options']
        }] }); })();
if (false) {
    /** @type {?} */
    KatexDirective.prototype.equation;
    /** @type {?} */
    KatexDirective.prototype.options;
    /** @type {?} */
    KatexDirective.prototype.onError;
    /**
     * @type {?}
     * @private
     */
    KatexDirective.prototype.el;
    /**
     * @type {?}
     * @private
     */
    KatexDirective.prototype.katexService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class KatexHtmlComponent {
    /**
     * @param {?} domSanitizer
     * @param {?} katexService
     */
    constructor(domSanitizer, katexService) {
        this.domSanitizer = domSanitizer;
        this.katexService = katexService;
    }
    /**
     * @return {?}
     */
    get allHtml() {
        /** @type {?} */
        let segments = this.segments;
        /** @type {?} */
        var allHtml = segments.map((/**
         * @param {?} seg
         * @return {?}
         */
        (seg) => {
            if (seg.math) {
                return this.katexService.renderToString(seg.raw, { displayMode: seg.type === 'display' });
            }
            else {
                return seg.value;
            }
        })).reduce((/**
         * @param {?} total
         * @param {?} current
         * @return {?}
         */
        (total, current) => {
            return total += current;
        }));
        return this.domSanitizer.bypassSecurityTrustHtml(allHtml);
    }
    /**
     * @return {?}
     */
    get segments() {
        return extractMath(this.html);
    }
}
KatexHtmlComponent.ɵfac = function KatexHtmlComponent_Factory(t) { return new (t || KatexHtmlComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.DomSanitizer), ɵngcc0.ɵɵdirectiveInject(KatexService)); };
KatexHtmlComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: KatexHtmlComponent, selectors: [["ng-katex-html"]], inputs: { html: "html" }, decls: 1, vars: 1, consts: [[3, "innerHTML"]], template: function KatexHtmlComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "span", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("innerHTML", ctx.allHtml, ɵngcc0.ɵɵsanitizeHtml);
    } }, encapsulation: 2 });
/** @nocollapse */
KatexHtmlComponent.ctorParameters = () => [
    { type: DomSanitizer },
    { type: KatexService }
];
KatexHtmlComponent.propDecorators = {
    html: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(KatexHtmlComponent, [{
        type: Component,
        args: [{
                selector: 'ng-katex-html',
                template: `<span [innerHTML]="allHtml"></span>`
            }]
    }], function () { return [{ type: ɵngcc2.DomSanitizer }, { type: KatexService }]; }, { html: [{
            type: Input
        }] }); })();
if (false) {
    /** @type {?} */
    KatexHtmlComponent.prototype.html;
    /**
     * @type {?}
     * @private
     */
    KatexHtmlComponent.prototype.domSanitizer;
    /**
     * @type {?}
     * @private
     */
    KatexHtmlComponent.prototype.katexService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class KatexModule {
}
KatexModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: KatexModule });
KatexModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function KatexModule_Factory(t) { return new (t || KatexModule)(); }, providers: [
        KatexService,
    ], imports: [[
            CommonModule,
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(KatexModule, { declarations: function () { return [KatexDirective,
        KatexComponent,
        KatexParagraphComponent,
        KatexHtmlComponent]; }, imports: function () { return [CommonModule]; }, exports: function () { return [KatexComponent,
        KatexParagraphComponent,
        KatexHtmlComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(KatexModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule,
                ],
                providers: [
                    KatexService,
                ],
                declarations: [
                    KatexDirective,
                    KatexComponent,
                    KatexParagraphComponent,
                    KatexHtmlComponent
                ],
                exports: [
                    KatexComponent,
                    KatexParagraphComponent,
                    KatexHtmlComponent
                ]
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { KatexComponent, KatexModule, KatexParagraphComponent, KatexService as ɵa, KatexDirective as ɵb, KatexHtmlComponent as ɵc };

//# sourceMappingURL=ng-katex.js.map